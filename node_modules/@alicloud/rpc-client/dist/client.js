"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 * This is for RPC SDK
 */
const tea_util_1 = __importDefault(require("@alicloud/tea-util"));
const credentials_1 = __importStar(require("@alicloud/credentials")), $Credential = credentials_1;
const rpc_util_1 = __importDefault(require("@alicloud/rpc-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
/**
 * Model for initing client
 */
class Config extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accessKeyId: 'accessKeyId',
            accessKeySecret: 'accessKeySecret',
            securityToken: 'securityToken',
            protocol: 'protocol',
            regionId: 'regionId',
            readTimeout: 'readTimeout',
            connectTimeout: 'connectTimeout',
            httpProxy: 'httpProxy',
            httpsProxy: 'httpsProxy',
            credential: 'credential',
            endpoint: 'endpoint',
            noProxy: 'noProxy',
            maxIdleConns: 'maxIdleConns',
            network: 'network',
            userAgent: 'userAgent',
            suffix: 'suffix',
            socks5Proxy: 'socks5Proxy',
            socks5NetWork: 'socks5NetWork',
            endpointType: 'endpointType',
            openPlatformEndpoint: 'openPlatformEndpoint',
            type: 'type',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            accessKeySecret: 'string',
            securityToken: 'string',
            protocol: 'string',
            regionId: 'string',
            readTimeout: 'number',
            connectTimeout: 'number',
            httpProxy: 'string',
            httpsProxy: 'string',
            credential: credentials_1.default,
            endpoint: 'string',
            noProxy: 'string',
            maxIdleConns: 'number',
            network: 'string',
            userAgent: 'string',
            suffix: 'string',
            socks5Proxy: 'string',
            socks5NetWork: 'string',
            endpointType: 'string',
            openPlatformEndpoint: 'string',
            type: 'string',
        };
    }
}
exports.Config = Config;
class Client {
    /**
     * Init client with Config
     * @param config config contains the necessary information to create a client
     */
    constructor(config) {
        if (tea_util_1.default.isUnset($tea.toMap(config))) {
            throw $tea.newError({
                code: "ParameterMissing",
                message: "'config' can not be unset",
            });
        }
        tea_util_1.default.validateModel(config);
        if (!tea_util_1.default.empty(config.accessKeyId) && !tea_util_1.default.empty(config.accessKeySecret)) {
            if (!tea_util_1.default.empty(config.securityToken)) {
                config.type = "sts";
            }
            else {
                config.type = "access_key";
            }
            let credentialConfig = new $Credential.Config({
                accessKeyId: config.accessKeyId,
                type: config.type,
                accessKeySecret: config.accessKeySecret,
                securityToken: config.securityToken,
            });
            this._credential = new credentials_1.default(credentialConfig);
        }
        else if (!tea_util_1.default.isUnset(config.credential)) {
            this._credential = config.credential;
        }
        else {
            throw $tea.newError({
                code: "ParameterMissing",
                message: "'accessKeyId' and 'accessKeySecret' or 'credential' can not be unset",
            });
        }
        this._network = config.network;
        this._suffix = config.suffix;
        this._endpoint = config.endpoint;
        this._protocol = config.protocol;
        this._regionId = config.regionId;
        this._userAgent = config.userAgent;
        this._readTimeout = config.readTimeout;
        this._connectTimeout = config.connectTimeout;
        this._httpProxy = config.httpProxy;
        this._httpsProxy = config.httpsProxy;
        this._noProxy = config.noProxy;
        this._socks5Proxy = config.socks5Proxy;
        this._socks5NetWork = config.socks5NetWork;
        this._maxIdleConns = config.maxIdleConns;
        this._endpointType = config.endpointType;
        this._openPlatformEndpoint = config.openPlatformEndpoint;
    }
    /**
     * Encapsulate the request and invoke the network
     * @param action api name
     * @param protocol http or https
     * @param method e.g. GET
     * @param version product version
     * @param authType when authType is Anonymous, the signature will not be calculate
     * @param pathname pathname of every api
     * @param query which contains request params
     * @param body content of request
     * @param runtime which controls some details of call api, such as retry times
     * @return the response
     */
    doRequest(action, protocol, method, version, authType, query, body, runtime) {
        return __awaiter(this, void 0, void 0, function* () {
            let _runtime = {
                timeouted: "retry",
                readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
                connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
                httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
                httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
                noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
                maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
                retry: {
                    retryable: runtime.autoretry,
                    maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
                },
                backoff: {
                    policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                    period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
                },
                ignoreSSL: runtime.ignoreSSL,
            };
            let _lastRequest = null;
            let _now = Date.now();
            let _retryTimes = 0;
            while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
                if (_retryTimes > 0) {
                    let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                    if (_backoffTime > 0) {
                        yield $tea.sleep(_backoffTime);
                    }
                }
                _retryTimes = _retryTimes + 1;
                try {
                    let request_ = new $tea.Request();
                    request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);
                    request_.method = method;
                    request_.pathname = "/";
                    request_.query = rpc_util_1.default.query(Object.assign({ Action: action, Format: "json", Timestamp: rpc_util_1.default.getTimestamp(), Version: version, SignatureNonce: tea_util_1.default.getNonce() }, query));
                    // endpoint is setted in product client
                    request_.headers = {
                        'x-acs-version': version,
                        'x-acs-action': action,
                        host: this._endpoint,
                        'user-agent': this.getUserAgent(),
                    };
                    if (!tea_util_1.default.isUnset(body)) {
                        let tmp = tea_util_1.default.anyifyMapValue(rpc_util_1.default.query(body));
                        request_.body = new $tea.BytesReadable(tea_util_1.default.toFormString(tmp));
                        request_.headers["content-type"] = "application/x-www-form-urlencoded";
                    }
                    if (!tea_util_1.default.equalString(authType, "Anonymous")) {
                        let accessKeyId = yield this.getAccessKeyId();
                        let accessKeySecret = yield this.getAccessKeySecret();
                        let securityToken = yield this.getSecurityToken();
                        if (!tea_util_1.default.empty(securityToken)) {
                            request_.query["SecurityToken"] = securityToken;
                        }
                        request_.query["SignatureMethod"] = "HMAC-SHA1";
                        request_.query["SignatureVersion"] = "1.0";
                        request_.query["AccessKeyId"] = accessKeyId;
                        let signedParam = Object.assign(Object.assign({}, request_.query), rpc_util_1.default.query(body));
                        request_.query["Signature"] = rpc_util_1.default.getSignatureV1(signedParam, request_.method, accessKeySecret);
                    }
                    _lastRequest = request_;
                    let response_ = yield $tea.doAction(request_, _runtime);
                    let obj = yield tea_util_1.default.readAsJSON(response_.body);
                    let res = tea_util_1.default.assertAsMap(obj);
                    if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                        throw $tea.newError({
                            code: `${Client.defaultAny(res["Code"], res["code"])}Error`,
                            message: `code: ${response_.statusCode}, ${Client.defaultAny(res["Message"], res["message"])} requestid: ${Client.defaultAny(res["RequestId"], res["requestId"])}`,
                            data: res,
                        });
                    }
                    return res;
                }
                catch (ex) {
                    if ($tea.isRetryable(ex)) {
                        continue;
                    }
                    throw ex;
                }
            }
            throw $tea.newUnretryableError(_lastRequest);
        });
    }
    /**
     * Get user agent
     * @return user agent
     */
    getUserAgent() {
        let userAgent = tea_util_1.default.getUserAgent(this._userAgent);
        return userAgent;
    }
    /**
     * Get accesskey id by using credential
     * @return accesskey id
     */
    getAccessKeyId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (tea_util_1.default.isUnset(this._credential)) {
                return "";
            }
            let accessKeyId = yield this._credential.getAccessKeyId();
            return accessKeyId;
        });
    }
    /**
     * Get accesskey secret by using credential
     * @return accesskey secret
     */
    getAccessKeySecret() {
        return __awaiter(this, void 0, void 0, function* () {
            if (tea_util_1.default.isUnset(this._credential)) {
                return "";
            }
            let secret = yield this._credential.getAccessKeySecret();
            return secret;
        });
    }
    /**
     * Get security token by using credential
     * @return security token
     */
    getSecurityToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (tea_util_1.default.isUnset(this._credential)) {
                return "";
            }
            let token = yield this._credential.getSecurityToken();
            return token;
        });
    }
    /**
     * If the endpointRule and config.endpoint are empty, throw error
     * @param config config contains the necessary information to create a client
     */
    checkConfig(config) {
        if (tea_util_1.default.empty(this._endpointRule) && tea_util_1.default.empty(config.endpoint)) {
            throw $tea.newError({
                code: "ParameterMissing",
                message: "'config.endpoint' can not be empty",
            });
        }
    }
    /**
     * If inputValue is not null, return it or return defaultValue
     * @param inputValue  users input value
     * @param defaultValue default value
     * @return the final result
     */
    static defaultAny(inputValue, defaultValue) {
        if (tea_util_1.default.isUnset(inputValue)) {
            return defaultValue;
        }
        return inputValue;
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map